While specific comments are available in each .java source file, this file acts as a more generalized source for what each algorithm does and how I implemented them.

Algorithm #1, Shaker Sort:
I implemented this algorithm in two different ways (well, the overall logic is the same for both): both functions have the same name, with one intended to sort an array of primitive double type, and the other intended to sort a generic array, so long as the object type implements the compareTo function.
Calling the function is relatively simple: shakerSort(array) - since this returns a sorted array, ideal usage would be array = shakerSort(array).
As for the logic behind the sort, we can think of it as a variation on the standard bubble sort, except here we move through the array in both directions (forwards and backwards) rather than just one. The logic follows standard bubble sorting logic in the way of swapping, except we first move through the array left-to-right, and then right-to-left, continuing until no more elements are swapped (in my implementation, until the boolean swapped stays false throughout an entire pass through the array). Compared to a bubble sort, the performance increases are only marginal, with average performance of O(n^2).

Main method documentation:
Here, we're just using a Random object to generate an array of random doubles (in this case, decimals between 0 and 1 from the nextDouble() function, but this is still enough to demonstrate the algorithm), with a bucket count between 2 and 5. We then sort the array, and print out the final sorted array.

Algorithm #2, Bucket Sort:
While I wanted to implement this algorithm in the same two-pronged fashion (primitive double as well as generic) as the Shaker Sort, the nature of the algorithm only allows efficient implementation for numbers/primitives. The function takes two variables: the array to be sorted, as well as the number of buckets to divide the array into: an ideal calling situation (as seen in my demo program) would be array = bucketSort(array, bucketCount).
The logic behind the sort is more complex than the shaker sort, though at a certain point an efficient sorting algorithm is still required to sort the individual buckets. We start by parsing through the array to find our highest and lowest numbers; we then determine the interval size for each bucket based on these values and our user-specified number of buckets. We then create an array of ArrayLists to store our buckets (a two-dimensional array could work as well, but an ArrayList jumped to mind when I was implementing the function), where we then add the values to their appropriate buckets based on their value relative to the interval. Rather than sorting each bucket one at a time, we create a thread pool with the maximum number of threads available on the computer - we then execute the Callable BucketSorter objects (more in detail on those below) on each thread, storing the result in an ArrayList of Future type - this eliminates the need to halt the main thread while waiting for all other threads to finish, as calling get() on an object of Future type will not successfully execute until that worker thread has finished. We then pass through the sorted buckets and replace the values of the original array with the sorted array.

BucketSorter type documentation:
The BucketSorter object implements Callable, allowing us to easily use it in the multi-threaded scenario that an efficient bucket sort implementation demands. The call() function is automatically called when the thread pool calls the submit() function on the worker object [aka BucketSorter type] - while the one line of the call function looks intimidating, it's actually rather simple. Using Java 8 streams, we convert our ArrayList<Double> to a primitive double[], pass this primitive to another sorting algorithm to sort the bucket (I called my primitive ShakerSort, but any sorting function that accepts a double[] type would work; one could also just convert the ArrayList to a Double[] array, so any function that accepts this parameter would work as well), and then use streams to convert the double[] BACK to an ArrayList<Double>; the 'ugliness' of this statement could be avoided by sorting and returning a non-primitive Double[] array, as we wouldn't need to use Java 8 streams to convert back to an ArrayList.

Main method documentation:
Here, we're just using a Random object to generate an array of random doubles (in this case, decimals between 0 and 1 from the nextDouble() function, but this is still enough to demonstrate the algorithm), with a bucket count between 2 and 5. We then sort the array, and print out the final sorted array.